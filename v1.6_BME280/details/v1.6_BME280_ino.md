# Deep Technical Documentation: v2_refactored.ino

> **Monolith Analysis**: Decomposed into 12 blocks.



## Analysis: Block 01
Here is the detailed technical analysis for **Block 01** of the firmware.

### 1. Block Title
**Block 01: Headers, Configuration, and Data Structures**

### 2. Responsibilities
This block acts as the foundation for the entire firmware. Its primary responsibilities are:
*   **Environment Setup**: Including necessary libraries for WiFi (ESP8266 specific), MQTT, I2C communication, and the BME280 sensor.
*   **System Configuration**: Defining hardcoded credentials for network access (WiFi SSID/Password) and backend communication (MQTT Broker, Credentials, Topics).
*   **Operational Parameters**: Setting timing constants for the "Adaptive Sampling" algorithm (varying report rates based on sensor stability) and connection retry logic.
*   **Hardware Abstraction**: Mapping logical I2C pins (SDA, SCL) and LED pins to the Wemos D1 Mini physical layout.
*   **Data Modeling**: Defining complex data structures (`struct`) to handle sensor readings and historical data buffering, including helper methods for calculating rate-of-change.

### 3. Key Functions/Variables

| Name | Type | Description |
| :--- | :--- | :--- |
| `MQTT_SERVER` / `PORT` | `const char*` / `uint16_t` | Target address for the MQTT Broker. |
| `TOPIC_STATUS` | `const char*` | MQTT Topic for LWT (Last Will and Testament) and online/offline status. |
| `TOPIC_WEATHER` | `const char*` | MQTT Topic where JSON sensor data payload will be published. |
| `INTERVAL_ULTRASHORT` ... `INTERVAL_LONG` | `unsigned long` | A set of timing tiers (2s, 6s, 15s, 30s) used by the adaptive logic to slow down reporting when the environment is stable. |
| `bme` | `Adafruit_BME280` | Global instance of the sensor driver. |
| `mqttClient` | `PubSubClient` | Global instance of the MQTT client wrapper. |
| `SensorData` | `struct` | Data container for current Temperature, Humidity, Pressure, and Sensor Health (`bme280Working`). |
| `SensorHistory` | `struct` | A circular buffer implementation to store the last `HISTORY_SIZE` (10) readings to calculate trends. |
| `SensorHistory::getChangeRate` | `function` | Calculates the rate of change per minute based on stored timestamps and values. |

### 4. State/Logic
While this block is primarily declarative, it contains one critical piece of encapsulated logic within the `SensorHistory` struct:

*   **Circular Buffering**: The struct maintains an `index` and a `filled` boolean. When `add()` is called, it overwrites the oldest value if the buffer is full, ensuring the array always holds the most recent 10 samples.
*   **Trend Calculation (`getChangeRate`)**:
    1.  This function determines the volatility of the environment.
    2.  It takes `sampleCount` as an input to decide how far back in history to compare.
    3.  It calculates the absolute difference (`fabs`) between the newest value and the oldest relevant value.
    4.  It normalizes this difference against the time delta (`timestamps`) to return a **Change Per Minute**.
    5.  *Purpose*: This logic allows the main loop (in later blocks) to decide if it should report data every 2 seconds (high volatility) or every 30 seconds (low volatility).

### 5. Integration
This block exposes the following logical components to the subsequent blocks (2-6):

*   **Global Objects**: `wifiClient`, `mqttClient`, and `bme` are instantiated here and will be initialized in `setup()` (likely Block 2 or 3) and used in `loop()` (Block 4+).
*   **Configuration Constants**: The WiFi and MQTT credentials and logic timers (`RECONNECT_INTERVAL_BASE`) are globally available for connection state machines.
*   **Type Definitions**: The `SensorData` and `SensorHistory` structs are defined here as types. Subsequent blocks will likely instantiate global variables of these types (e.g., `SensorData currentData;`) to store runtime state.
*   **Hardware Platform**: The code explicitly defines `D1` and `D2` (ESP8266 specific pin mappings), forcing subsequent `Wire.begin()` calls to use these specific pins.

*Note: Although the context mentions ESP32, this specific block includes `<ESP8266WiFi.h>` and pin definitions for "Wemos D1 Mini", indicating this firmware is designed for an ESP8266 node within the larger automation system.*

---


## Analysis: Block 02
Here is the detailed analysis of **Block 02** of the monolithic firmware.

### 1. Block Title
**Block 02: Global State Definitions & Adaptive Sampling Logic**

### 2. Responsibilities
This block acts as the **state manager** and **adaptive logic engine** for the system. Its primary responsibilities are:
*   **Sensor History Management**: Instantiating history buffers to track temperature, humidity, and pressure trends over time.
*   **Global Variable Declaration**: Defining the central data structures (`SensorData`), flags (`wifiConnected`, `mqttConnected`), and timers (`lastSensorRead`, `uptimeSeconds`) that will be accessed by the rest of the system.
*   **Adaptive Sampling Algorithm**: Implementing a state machine that dynamically adjusts the sensor reading interval (`currentSensorInterval`) based on the stability of the environment. If values are changing rapidly, it samples frequently; if stable, it saves energy/cycles by sampling less often.

### 3. Key Functions & Variables

#### Global Variables
| Variable Name | Type | Purpose |
| :--- | :--- | :--- |
| `tempHistory`, `humidityHistory`... | `SensorHistory` | Objects storing ring buffers of recent sensor readings (Class defined in Block 01). |
| `sensorData`, `lastSensorData` | `SensorData` | Structs holding current and previous measurements. |
| `currentMode` | `AdaptiveMode` | Enum tracking current sampling state (`ULTRASHORT`, `SHORT`, `MEDIUM`, `LONG`). |
| `currentSensorInterval` | `unsigned long` | The actual delay (in ms) between sensor reads, derived from `currentMode`. |
| `wifiConnected`, `mqttConnected` | `bool` | Global flags indicating network status. |
| `uptimeSeconds` | `unsigned long` | Tracks total system runtime. |
| `lastSensorRead` | `unsigned long` | Timestamp of the last hardware read. |

#### Functions
| Function Name | Description |
| :--- | :--- |
| `updateHistories()` | Pushes the current `sensorData` values into the respective `SensorHistory` objects with a timestamp. |
| `checkSamplingMode()` | The core logic engine. analyzes history stability, enforces wait times, and transitions the system between sampling modes (intervals). |

### 4. State & Logic Analysis

The most complex logic in this block is within `checkSamplingMode()`. It operates as a **Promotion/Demotion State Machine**:

**1. Stability Check:**
*   It calculates the rate of change for Temperature (threshold: `0.5` unit/min) and Humidity (threshold: `2.0` unit/min).
*   If both are below thresholds, the system is considered **Stable**.

**2. Demotion (Instability):**
*   **Trigger**: If stability is lost at any moment.
*   **Action**: Immediate reset to `ULTRASHORT_INTERVAL` (fastest sampling).
*   **Logic**: Safety first—if the environment is changing, the system needs high-resolution data immediately.

**3. Promotion (Stability):**
*   **Requirement**: The system must be continuously stable for **5 minutes** (`stabilityDuration >= 5`) before any promotion occurs.
*   **Step-up Logic**:
    *   **UltraShort -> Short**: After 10 minutes in UltraShort.
    *   **Short -> Medium**: After 10 minutes in Short.
    *   **Medium -> Long**: After 15 minutes in Medium.
*   **Goal**: Gradually reduce sampling frequency to save resources only when the environment is proven to be very stable over long periods.

### 5. Integration Points

This block bridges the definitions from Block 01 with the execution logic in later blocks:

*   **From Block 01**: It closes the `SensorHistory` class and immediately instantiates objects (`tempHistory`) using that class.
*   **To Block 03 (Setup/Connect)**: It provides the `wifiConnected` and `reconnectInterval` variables that the connection logic will manipulate.
*   **To Block 04/05 (Main Loop)**:
    *   `currentSensorInterval` is the "heartbeat" variable. The main loop uses this to decide when to trigger a new sensor read.
    *   `sensorData` is the struct where hardware drivers (in later blocks) will write their values.
    *   `updateHistories()` will be called inside the main loop after a successful read.

**Note on Critical Coupling**: The `checkSamplingMode()` function relies on specific constants (`INTERVAL_SHORT`, `INTERVAL_MEDIUM`, etc.) which are likely defined in a header file or at the very top of Block 01 (not shown in this snippet, but implied by usage).

---


## Analysis: Block 03
Here is the detailed technical analysis for **Block 03** of the Monolithic Firmware.

### 1. Block Title
**Block 03: Connectivity & Sensor Initialization**

### 2. Responsibilities
This block is responsible for the "bootstrap" phase of the device's external communications and environmental sensing. Its specific duties include:
*   **Hardware Abstraction**: initializing the I2C bus and the BME280 environmental sensor with address auto-detection and fallback configurations.
*   **Network Transport**: Establishing the WiFi connection (blocking approach with timeout) to ensure the device has IP connectivity before proceeding.
*   **Application Layer Protocol**: Managing the MQTT connection state using a non-blocking, exponential backoff strategy, and handling device "Presence" (Online/Offline status) via LWT (Last Will and Testament) and Retained messages.

### 3. Key Functions & Variables

| Element | Type | Description |
| :--- | :--- | :--- |
| **`initSensors()`** | `bool` | Initializes I2C on specific pins (`BME_SDA`, `BME_SCL`). Probes BME280 addresses `0x76` and `0x77`. Configures sampling/filtering. Returns `true` if sensor is found. |
| **`connectWiFi()`** | `void` | Blocking function (up to 15s) to connect to WiFi. Controls `LED_BUILTIN` to indicate status (blinking=connecting, ON=connected, OFF=fail). |
| **`connectMQTT()`** | `void` | **Non-blocking** function called repeatedly in the loop. Manages connection to the MQTT broker using a timer-based retry mechanism with exponential backoff. |
| `sensorData` | `struct` | Global structure (implied from previous blocks) holding the flag `bme280Working`. |
| `bme` | `Object` | Instance of `Adafruit_BME280`. |
| `mqttClient` | `Object` | Instance of the MQTT client (likely `PubSubClient`). |
| `reconnectInterval` | `long` | Dynamic interval for MQTT retries (increases on failures). |
| `wifiConnected` | `bool` | Global flag tracking WiFi state. |
| `mqttConnected` | `bool` | Global flag tracking MQTT state. |
| `TOPIC_STATUS` | `const` | MQTT topic used for device presence/heartbeat. |

### 4. State & Logic Flow

#### A. Sensor Initialization (`initSensors`)
1.  **I2C Setup**: Starts the `Wire` library on specific GPIOs defined by `BME_SDA` and `BME_SCL`.
2.  **Address Scanning**:
    *   Attempts to find BME280 at `0x76` (common for modules).
    *   If failed, attempts `0x77` (Adafruit default).
    *   If both fail, sets `sensorData.bme280Working = false`.
3.  **Configuration**: If found, applies specific settings (Normal Mode, Oversampling x2/x16, Filter x16).
4.  **Verification**: Performs a dummy read. If `readTemperature()` returns `NaN`, it attempts a "Safe Mode" reconfiguration (reduced oversampling, filter off) to attempt recovery.

#### B. WiFi Connection (`connectWiFi`)
*   **Blocking Behavior**: This function halts program execution for up to 15 seconds while attempting to connect.
*   **Visual Feedback**: Uses `LED_BUILTIN` (Active LOW logic implied) to blink while negotiating.
*   **Outcome**:
    *   Success: Prints IP, sets `wifiConnected = true`, turns LED ON (idle state).
    *   Failure: Prints error, sets `wifiConnected = false`, turns LED OFF (error state).

#### C. MQTT Connection Strategy (`connectMQTT`)
*   **Pre-conditions**: Only runs if WiFi is connected and the `reconnectInterval` time has passed.
*   **Identity**: Generates a random Client ID (`MQTT_CLIENT_ID_BASE` + Random Hex) to prevent collisions on the broker.
*   **LWT (Last Will and Testament)**: Registers a "will" message (`{"status":"offline"}`) on `TOPIC_STATUS`. If the ESP32 loses power or crashes, the Broker sends this message automatically to subscribers.
*   **Connection Attempt**:
    *   **Success**: Resets retry counters. Publishes a **Retained** JSON message to `TOPIC_STATUS` containing IP, RSSI, Uptime, and Firmware version. This ensures any dashboard subscribing later immediately sees the device details.
    *   **Failure**: Increments `failedReconnectCount`.
*   **Exponential Backoff**: If connection fails, `reconnectInterval` is doubled (multiplied by 2) until it hits `RECONNECT_INTERVAL_MAX`. This prevents the device from flooding the network/broker during outages.

### 5. Integration with Other Blocks

*   **Block 01/02 (Globals)**: Relies on `sensorData` struct, `WIFI_SSID`, `MQTT_SERVER`, and pin definitions (`BME_SDA`, `LED_BUILTIN`).
*   **Block 04/05 (Main Loop)**: The `connectMQTT()` function is designed to be called cyclically from the main loop. It does not block, allowing the Regulation Loop (Block 05) to continue functioning (locally) even if MQTT is down.
*   **System Status**: Updates global flags (`wifiConnected`, `mqttConnected`, `sensorData.bme280Working`) which determine if the system operates in "Online" or "Local/Offline" mode in subsequent blocks.

---


## Analysis: Block 04
## Block 04 Analysis: Connectivity Maintenance & Sensor Acquisition

This block contains the core runtime logic for maintaining network stability, reporting device health telemetry, and acquiring environmental data with robust error handling. It serves as the bridge between the system's state and the external world (MQTT broker & Physical Environment).

### 1. Responsibilities
*   **System Telemetry**: Periodically aggregates device diagnostics (uptime, RSSI, Heap, IP) into a JSON payload and publishes it via MQTT.
*   **Connection Keep-Alive**: Monitors WiFi and MQTT connection states. It handles automatic reconnection logic and executes the critical `mqttClient.loop()` to process incoming messages.
*   **Robust Sensor Reading**: Interfaces with the BME280 sensor. It implements data validation, outlier rejection, and an automatic "self-healing" re-initialization routine if the I2C bus hangs or returns invalid data.
*   **Visual Feedback**: Toggles the onboard LED (`LED_BUILTIN`) to indicate processor activity during network transmission or sensor acquisition.

### 2. Key Functions & Variables

| Function / Variable | Type | Description |
| :--- | :--- | :--- |
| **`publishSystemStatus()`** | `void` | Constructs a JSON string containing device health metrics and publishes it to `TOPIC_SYSTEM`. |
| **`checkConnections()`** | `void` | The connectivity watchdog. Manages WiFi re-connection (non-blocking) and MQTT re-connection calls. Runs the MQTT loop. |
| **`readSensors()`** | `void` | Reads BME280 data. Includes multi-stage error correction (retry -> re-init -> disable). |
| `sensorData` | `struct` | Global structure (defined in previous blocks) updated here with `temperature`, `humidity`, `pressure`. |
| `bme` | `Object` | Adafruit_BME280 instance used for I2C communication. |
| `mqttClient.loop()` | `Method` | **Critical**: Processes incoming MQTT packets and keeps the keep-alive ping active. |
| `WiFi.RSSI()` | `Method` | Reads signal strength (dBm) for diagnostics. |
| `ESP.getFreeHeap()` | `Method` | Diagnostics for memory leak detection. |

### 3. State & Logic Flow

#### A. Telemetry Logic (`publishSystemStatus`)
1.  **Check**: If MQTT is disconnected, abort immediately.
2.  **Activity Indicator**: Turn LED ON (Logic LOW).
3.  **Formatting**: A JSON buffer (`statusPayload`) is formatted using `snprintf`. It converts the internal `enum` for **Sample Mode** (ULTRASHORT, SHORT, etc.) into human-readable strings.
4.  **Publish**: Sends data to the defined `TOPIC_SYSTEM`.
5.  **Finish**: Turn LED OFF.

#### B. Watchdog Logic (`checkConnections`)
This function is designed to be called in the main `loop()`.
1.  **WiFi Check**:
    *   If disconnected (`!WL_CONNECTED`):
        *   Sets `wifiConnected` and `mqttConnected` flags to `false`.
        *   Uses a non-blocking timer (`millis() - lastWifiAttempt > 5000`) to retry `connectWiFi()` every 5 seconds.
    *   If connected: Updates flags.
2.  **MQTT Check** (Only runs if WiFi is active):
    *   Detects if the client dropped connection unexpectedly.
    *   If disconnected: Resets the exponential backoff timer (`reconnectInterval`) and calls `connectMQTT()` (from Block 03).
    *   **Crucial Step**: If connected, it calls `mqttClient.loop()`. Without this, the ESP32 cannot receive subscription callbacks (Block 03), rendering remote control impossible.

#### C. Self-Healing Sensor Logic (`readSensors`)
This function implements an industrial-grade "Try-Catch-Repair" pattern for I2C sensors.
1.  **Read**: Attempts to fetch Temperature, Humidity, and Pressure.
2.  **Validate**: Checks specific bounds to reject noise:
    *   Temp: -40 to 85°C
    *   Hum: 0 to 100%
    *   Press: 800 to 1200 hPa
    *   Checks for `isnan()` (Not a Number).
3.  **Recovery Level 1 (Retry)**:
    *   If validation fails, waits 50ms and reads again.
4.  **Recovery Level 2 (Hard Reset)**:
    *   If retry fails, it attempts to **Re-initialize** the BME280 hardware (`bme.begin()`). It scans both common I2C addresses (`0x76`, `0x77`).
    *   If successful, it re-applies sampling settings and attempts a read.
5.  **Failure**:
    *   If all recovery attempts fail, `sensorData.bme280Working` is set to `false` to prevent the system from acting on bad data in the regulation loop.

### 4. Integration Points

*   **Exposed to Block 05/06 (Main Loop)**:
    *   `checkConnections()` must be called in every loop iteration to maintain cloud link.
    *   `readSensors()` provides the raw inputs (`sensorData.temperature`) required for the heating/ventilation regulation logic in the next blocks.
    *   `publishSystemStatus()` provides visibility to the frontend/dashboard.
*   **Dependencies from Block 01/02/03**:
    *   Requires `wifiConnected`, `mqttConnected`, `reconnectCount` globals.
    *   Requires `mqttClient` instance and `connectWiFi()` / `connectMQTT()` functions defined in Block 03.
    *   Requires `sensorData` struct definition.

---


## Analysis: Block 05
# Block 05: Data Publishing, Safety Watchdog & System Setup

This block contains the logic for transmitting telemetry data, implementing a "self-healing" mechanism for network failures, and the standard Arduino `setup()` routine that initializes the entire system.

## 1. Responsibilities
*   **MQTT Telemetry Transmission**: Formatting sensor data into JSON and publishing it to the MQTT broker.
*   **Visual Feedback**: controlling the onboard LED to indicate transmission activity or sensor errors.
*   **Connection Watchdog (Safety)**: Monitoring network connectivity over time and forcing a hardware reboot (`ESP.restart()`) if the device remains disconnected for too long.
*   **System Initialization**: The `setup()` entry point that orchestrates Serial, GPIO, Sensor, WiFi, and State Machine initialization.

## 2. Key Functions & Variables

| Name | Type | Description |
| :--- | :--- | :--- |
| **Functions** | | |
| `publishSensorData` | `void` | Formats `sensorData` into a JSON string and publishes it to `TOPIC_WEATHER`. Accepts a `repeatCount` argument to send multiple rapid updates (burst mode). |
| `checkEmergencyRestart` | `void` | Checks how long the device has been disconnected. Triggers a system reset if thresholds (`MAX_DISCONNECT_TIME` or `MAX_FAILED_RECONNECTS`) are exceeded. |
| `setup` | `void` | Standard Arduino setup. Initializes Serial, LED, Sensors, WiFi, MQTT, History buffers, and sets the initial sampling mode. |
| **Global Variables** | | |
| `sensorData` | `struct` | Source of temperature, humidity, and pressure values used in the payload. |
| `mqttConnected` | `bool` | Gatekeeping flag; data is only published if true. |
| `disconnectStartTime` | `ulong` | Timestamp of when connectivity was lost. Used to calculate duration for the watchdog. |
| `wasEverConnected` | `bool` | Prevents the watchdog from resetting the device during the very first boot up before connection is established. |
| `currentMode` | `enum/int` | Initialized to `ULTRASHORT_INTERVAL` in setup to gather data quickly on boot. |
| **Constants** | | |
| `TOPIC_WEATHER` | `const` | MQTT topic string. |
| `LED_BUILTIN` | `int` | Onboard LED pin. Logic is inverted (LOW = ON) typical of Wemos D1 Mini boards. |

## 3. State & Logic Analysis

### Data Publishing Logic (`publishSensorData`)
1.  **Check Connection**: Returns immediately if MQTT is not connected.
2.  **Visual Indication**: Turns the LED **ON** (Logic LOW) to signal activity.
3.  **Payload Creation**: Uses `snprintf` to create a JSON string: `{"temp":X,"hum":Y,"pres":Z,"repeat":N}`.
4.  **Burst Mode**: The loop allows sending the same data frame multiple times (`repeatCount`), adding a `delay(500)` between sends. This is likely used for debugging or ensuring delivery in noisy environments.
5.  **Cleanup**: Turns LED **OFF** (Logic HIGH).

### Watchdog Logic (`checkEmergencyRestart`)
This function implements a "Dead Man's Switch" for network connectivity:
*   **Pre-requisite**: The device must have successfully connected at least once (`wasEverConnected == true`).
*   **Trigger**: If WiFi OR MQTT is disconnected:
    *   It records the `disconnectStartTime`.
    *   **Time Check**: If `now - disconnectStartTime > MAX_DISCONNECT_TIME` (typically > 1 hour based on logs), it calls `ESP.restart()`.
    *   **Retry Check**: If `failedReconnectCount > MAX_FAILED_RECONNECTS`, it calls `ESP.restart()`.
*   **Reset**: If both WiFi and MQTT are connected, it resets counters and `disconnectStartTime` to 0.

### Setup Sequence
The `setup()` function dictates the boot order:
1.  **Serial**: 115200 baud.
2.  **Hardware**: LED configured.
3.  **Sensors**: Calls `initSensors()` (Block 02). If BME280 fails, it enters a blocking visual error loop (blinks LED 10 times).
4.  **Network**: Calls `connectWiFi()` (Block 03).
5.  **MQTT**: Configures Server, Port, and KeepAlive.
6.  **Data Structures**: Initializes `History` buffers (Block 04) for trend analysis.
7.  **State Machine**: Sets the system to `ULTRASHORT_INTERVAL` mode to ensure rapid data collection immediately after boot.

## 4. Integration with Other Blocks

*   **Prerequisites**:
    *   **Block 02**: Requires `initSensors()` and `sensorData` struct.
    *   **Block 03**: Requires `connectWiFi()`, `mqttClient`, and network status flags (`wifiConnected`, `mqttConnected`).
    *   **Block 04**: Requires the `History` class definitions (referenced here as `tempHistory`, etc.).
*   **Exposed to Block 06 (Loop)**:
    *   Sets `currentMode`, `currentSensorInterval`, and `modeStartTime`. The main loop (Block 06) will rely on these values to determine when to take the next reading.
    *   `checkEmergencyRestart()` is designed to be called cyclically from the main loop.

---


## Analysis: Block 06
# Block 06: Main Execution Loop

## 1. Responsibilities
This final block serves as the **central scheduler and orchestrator** of the firmware. It does not define new helper logic but rather executes the functions defined in Blocks 01–05 based on specific timing constraints. Its primary responsibilities include:

*   **Task Scheduling**: Managing non-blocking timing for sensor reading (`currentSensorInterval`) and system status reporting (`STATUS_INTERVAL`).
*   **Watchdog Management**: Feeding the hardware watchdog to prevent unexpected resets.
*   **Connection Maintenance**: Continuously validating WiFi and MQTT connectivity.
*   **Data Pipeline Execution**: Triggering the acquisition -> processing -> history update -> transmission pipeline.
*   **Adaptive Behavior**: Evaluating sensor data to dynamically switch between "Short" and "Long" sampling intervals.
*   **Uptime Tracking**: Maintaining a continuous count of system runtime.

## 2. Key Functions & Variables

| Element | Type | Description |
| :--- | :--- | :--- |
| `loop()` | **Function** | The standard Arduino infinite execution loop. |
| `checkConnections()` | Function Call | (From Block 02) Reconnects WiFi/MQTT if dropped. |
| `readSensors()` | Function Call | (From Block 03) Acquires raw data from HW sensors. |
| `updateHistories()` | Function Call | (From Block 04) Updates the rolling buffers for temp/pressure/humidity. |
| `publishSensorData()` | Function Call | (From Block 05) Serializes and sends JSON payload via MQTT. |
| `checkSamplingMode()` | Function Call | (From Block 04) Decides if sampling rate should change based on volatility. |
| `checkEmergencyRestart()`| Function Call | (From Block 02) Checks if a forced reboot is pending. |
| `ESP.wdtFeed()` | System Call | Resets the hardware watchdog timer (Critical for system stability). |
| `currentSensorInterval`| `unsigned long` | The dynamic delay between sensor reads (can vary between `SHORT_INTERVAL` and `LONG_INTERVAL`). |
| `lastSensorRead` | `unsigned long` | Timestamp tracking the last time sensors were polled. |
| `sensorData` | `struct` | Global structure holding the latest readings and BME280 status. |
| `mqttClient.loop()` | Library Call | Processes incoming MQTT messages (keep-alive, callbacks). |

## 3. State & Logic Analysis

The loop follows a **Non-Blocking Super-Loop Architecture**. It does not use `delay()` for long waits, allowing the processor to handle network tasks continuously.

1.  **High-Frequency Maintenance**:
    *   **Watchdog**: `ESP.wdtFeed()` is called immediately to assert system health.
    *   **Network**: `checkConnections()` ensures the link is up. `mqttClient.loop()` handles the TCP network stack and incoming subscriptions.
    *   **Uptime**: Increments `uptimeSeconds` once every 1000ms.

2.  **Sensor Cycle (Variable Timing)**:
    *   The code checks `if (now - lastSensorRead >= currentSensorInterval)`.
    *   **Acquisition**: Calls `readSensors()`.
    *   **Processing**: If the BME280 is functional, it calls `updateHistories()` to calculate trends (Rising/Falling/Stable).
    *   **Transmission**: If MQTT is connected, it calls `publishSensorData()`.
        *   *Logic Note*: If the system is in `LONG_INTERVAL` mode, it publishes data `REPEAT_COUNT` times (redundancy strategy to ensure delivery during long silence periods). In standard mode, it sends once.
    *   **Adaptation**: Calls `checkSamplingMode()` to determine if the `currentSensorInterval` should be tightened (event detected) or relaxed (stable).

3.  **System Status Cycle (Fixed Timing)**:
    *   Independently of sensor readings, every `STATUS_INTERVAL`, the system broadcasts its health (WiFi signal, uptime, mode) via `publishSystemStatus()`.

4.  **Stability**:
    *   A hardcoded `delay(10)` exists at the end to yield time to the ESP32/ESP8266 background WiFi stack/OS tasks to prevent soft-watchdog resets.

## 4. Integration with Previous Blocks

This block is the **Consumer** of the entire monolithic structure:

*   **Block 01 (Config)**: Uses `STATUS_INTERVAL`, `REPEAT_COUNT`, and pin definitions indirectly.
*   **Block 02 (Network/Utils)**: Relies on `mqttConnected` flag, `checkConnections()`, and `checkEmergencyRestart()`.
*   **Block 03 (Sensors)**: Triggers `readSensors()` and utilizes the `sensorData` struct structure.
*   **Block 04 (Logic/Reg)**: Uses `updateHistories()` and `checkSamplingMode()` to drive the adaptive logic state machine.
*   **Block 05 (MQTT)**: Calls `publishSensorData()` and `publishSystemStatus()` to export the state generated by blocks 03 and 04.

This completes the analysis of the Monolithic Firmware. The system is designed as a reactive, adaptive IoT sensor node that prioritizes data continuity and self-recovery.

---
